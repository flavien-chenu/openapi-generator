using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using Microsoft.OpenApi;

namespace Argon.OpenApiGenerator.Controllers;

/// <summary>
/// Generator for controllers from OpenAPI paths.
/// </summary>
public class ControllerGenerator
{
    private readonly GeneratorConfiguration _configuration;

    public ControllerGenerator(GeneratorConfiguration configuration)
    {
        _configuration = configuration;
    }

    public string Generate(OpenApiDocument document, string fileName)
    {
        if (document.Paths.Count == 0)
            return string.Empty;

        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Usings
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.AspNetCore.Mvc;");

        sb.AppendLine();

        // Namespace
        var fullNamespace = string.IsNullOrWhiteSpace(_configuration.BaseNamespace)
            ? _configuration.ControllersNamespace
            : $"{_configuration.BaseNamespace}.{_configuration.ControllersNamespace}";

        sb.AppendLine($"namespace {fullNamespace};");
        sb.AppendLine();

        // Groupe les paths par tag ou par préfixe de route
        var controllerGroups = GroupPathsByController(document.Paths);
        var definitions = controllerGroups.Select(group => GetDefinition(group.Key, group.Value, document)).ToList();

        // Génère les contrôleurs
        foreach (var definition in definitions)
        {
            GenerateController(sb, definition);
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static Dictionary<string, List<(string Path, IOpenApiPathItem PathItem)>> GroupPathsByController(
        OpenApiPaths paths)
    {
        var groups = new Dictionary<string, List<(string, IOpenApiPathItem)>>();

        foreach (var path in paths)
        {
            // Use the first segment of the path as controller name
            var segments = path.Key.Split(new []{ '/' }, StringSplitOptions.RemoveEmptyEntries);
            var controllerName = segments.Length > 0
                ? SanitizeName(segments[0], pascalCase: true)
                : "Default";

            // Or use the tag from the first operation
            if (path.Value.Operations is null || path.Value.Operations.Count == 0) continue;

            var firstOperation = path.Value.Operations.FirstOrDefault().Value;
            if (firstOperation?.Tags?.Count > 0)
            {
                var name = firstOperation.Tags.First()?.Name;
                if (name != null) controllerName = SanitizeName(name, pascalCase: true);
            }

            if (!groups.ContainsKey(controllerName))
            {
                groups[controllerName] = new List<(string, IOpenApiPathItem)>();
            }

            groups[controllerName].Add((path.Key, path.Value));
        }

        return groups;
    }

    private ControllerDefinition GetDefinition(string controllerName, List<(string Path, IOpenApiPathItem PathItem)> paths, OpenApiDocument document)
    {
        var definition = new ControllerDefinition(controllerName)
        {
            Route = GetCommonPathPrefix(paths.Select(p => p.Path).ToList()),
            Documentation = $"Controller for {controllerName}",
        };

        definition.Methods = GetMethodsDefinition(definition, paths, document);
        return new ControllerDefinition(controllerName);
    }

    private List<ControllerMethodDefinition> GetMethodsDefinition(
        ControllerDefinition controller,
        List<(string Path, IOpenApiPathItem PathItem)> paths,
        OpenApiDocument document)
    {
        var methods = new List<ControllerMethodDefinition>();

        foreach (var (path, pathItem) in paths)
        {
            foreach (var operation in pathItem.Operations ?? new Dictionary<HttpMethod, OpenApiOperation>())
            {
                methods.Add(GetMethodDefinition(controller, operation.Key, operation.Value, path, document));
            }
        }

        return methods;
    }

    private ControllerMethodDefinition GetMethodDefinition(
        ControllerDefinition controller,
        HttpMethod httpMethod,
        OpenApiOperation operation,
        string path,
        OpenApiDocument document)
    {
        var methodDefinition = new ControllerMethodDefinition
        {
            Name = GetMethodName(operation, path, httpMethod),
            HttpMethod = httpMethod,
            Route = ConvertPathToRouteTemplate(path).Remove(0, controller.Route.Length).TrimStart('/'),
            Documentation = operation.Summary ?? operation.Description ?? "No description available.",
            ReturnType = GetReturnType(operation),
            Deprecated = operation.Deprecated
        };

        // Parameters
        if (operation.Parameters != null)
        {
            var i = 0;
            foreach (var param in operation.Parameters)
            {
                methodDefinition.Parameters.Add(new ControllerParameterDefinition
                {
                    Name = SanitizeName(param.Name ?? $"param{i}"),
                    Type = GetParameterType(param),
                    Documentation = param.Description ?? string.Empty,
                    Source = param.In switch
                    {
                        ParameterLocation.Query => ControllerParameterSource.Query,
                        ParameterLocation.Header => ControllerParameterSource.Header,
                        ParameterLocation.Path => ControllerParameterSource.Path,
                        _ => ControllerParameterSource.Default
                    },
                    IsRequired = param.Required || param.In is ParameterLocation.Path,
                    DefaultValue = param.Schema?.Default?.ToString()
                });
                i += 1;
            }
        }

        // Request body
        if (operation.RequestBody != null)
        {
            methodDefinition.Parameters.Add(new ControllerParameterDefinition
            {
                Name = "request",
                Type = GetRequestBodyType(operation.RequestBody, document),
                Source = ControllerParameterSource.Body,
                IsRequired = operation.RequestBody.Required,
                Documentation = operation.RequestBody.Description ?? string.Empty,
            });
        }

        return methodDefinition;
    }

    private void GenerateController(
        StringBuilder sb,
        ControllerDefinition definition)
    {
        // XML Documentation
        if (_configuration.GenerateXmlDocumentation)
        {
            sb.AppendLine("/// <summary>");
            sb.AppendLine($"/// {EscapeXmlComment(definition.Documentation)}");
            sb.AppendLine("/// </summary>");
        }

        // Attributes
        if (_configuration.AddApiControllerAttribute)
        {
            sb.AppendLine("[ApiController]");
        }

        // Utiliser le préfixe commun dans la route du contrôleur
        if (!string.IsNullOrEmpty(definition.Route))
        {
            sb.AppendLine($"[Route(\"{definition.Route}\")]");
        }

        // Class
        sb.AppendLine($"public abstract class {definition.Name}ControllerBase : ControllerBase");
        sb.AppendLine("{");

        // Generate methods for each operation
        foreach (var method in definition.Methods)
        {
            GenerateControllerMethod(sb, method);
            sb.AppendLine();
        }

        sb.AppendLine("}");
    }

    private static string GetCommonPathPrefix(List<string> paths)
    {
        switch (paths.Count)
        {
            case 0:
                return string.Empty;
            case > 0:
            {
                // Pour un seul path, on prend tout sauf le dernier segment
                var segments = paths[0].Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries);
                if (segments.Length <= 1) return string.Empty;
                return "/" + string.Join("/", segments.Take(segments.Length - 1));
            }
        }

        // Diviser tous les paths en segments
        var allSegments = paths.Select(p => p.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries).ToList()).ToList();

        // Trouver le nombre minimum de segments
        var minSegments = allSegments.Min(s => s.Count);
        if (minSegments == 0) return string.Empty;

        var commonSegments = new List<string>();

        // Comparer segment par segment
        for (int i = 0; i < minSegments; i++)
        {
            var firstSegment = allSegments[0][i];

            // Vérifier si tous les paths ont le même segment à cette position
            // On ignore les segments qui sont des paramètres (contiennent {})
            if (firstSegment.Contains("{")) break;

            if (allSegments.All(segments => segments[i] == firstSegment))
            {
                commonSegments.Add(firstSegment);
            }
            else
            {
                break;
            }
        }

        return commonSegments.Count > 0 ? "/" + string.Join("/", commonSegments) : string.Empty;
    }

    private void GenerateControllerMethod(
        StringBuilder sb,
        ControllerMethodDefinition method)
    {
        const string indent = "    ";

        // XML Documentation
        if (_configuration.GenerateXmlDocumentation)
        {
            var description = string.IsNullOrWhiteSpace(method.Documentation)
                ? "No description available."
                : method.Documentation;

            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// {EscapeXmlComment(description)}");
            sb.AppendLine($"{indent}/// </summary>");

            foreach (var param in method.Parameters)
            {
                sb.AppendLine($"{indent}/// <param name=\"{SanitizeName(param.Name)}\">{EscapeXmlComment(param.Documentation)}</param>");
            }
        }

        // HTTP Method attribute
        // Retirer le préfixe commun du path
        var routePath = method.Route;
        var routeMethod = SanitizeName(method.HttpMethod.Method.ToLower(), pascalCase: true);
        sb.AppendLine(string.IsNullOrEmpty(routePath) ? $"{indent}[Http{routeMethod}]" : $"{indent}[Http{routeMethod}(\"{routePath}\")]");

        // Method signature
        var asyncKeyword = _configuration.UseAsyncControllers ? "async " : "";
        var taskWrapper = _configuration.UseAsyncControllers ? "Task<" : "";
        var taskEnd = _configuration.UseAsyncControllers ? ">" : "";

        sb.Append($"{indent}public asbtract {asyncKeyword}{taskWrapper}{method.ReturnType}{taskEnd} {method.Name}(");

        // Parameters
        var parameters = new List<string>();

        foreach (var param in method.Parameters)
        {
            var paramAttribute = GetParameterAttribute(param.Source);

            parameters.Add($"{paramAttribute}{param.Type} {param.Name}");
        }

        // Request body
        /*if (operation.RequestBody != null)
        {
            var bodyType = GetRequestBodyType(operation.RequestBody, document);
            parameters.Add($"[FromBody] {bodyType} request");
        }*/

        sb.Append(string.Join(", ", parameters));
        sb.AppendLine(");");

        /*// Method body
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    // TODO: Implement logic");

        if (_configuration.UseAsyncControllers)
        {
            sb.AppendLine($"{indent}    await Task.CompletedTask;");
        }

        sb.AppendLine($"{indent}    throw new NotImplementedException();");
        sb.AppendLine($"{indent}}}");*/
    }

    private static string GetMethodName(OpenApiOperation operation, string path, HttpMethod httpMethod)
    {
        if (operation.OperationId is not null && !string.IsNullOrWhiteSpace(operation.OperationId))
        {
            return SanitizeName(operation.OperationId, pascalCase: true);
        }

        // Fallback: use HTTP method + path segments
        var flatName = httpMethod.ToString().ToLower() + '_' + path.Replace("/", "_")
            .Replace("{", "_by_")
            .Replace("}", "")
            .ToLower();
        return SanitizeName(flatName, pascalCase: true);
    }

    private static string GetReturnType(OpenApiOperation operation)
    {
        if (operation.Responses == null || operation.Responses.Count == 0)
        {
            return "IActionResult";
        }

        // Look for success response (2xx)
        var successResponse = operation.Responses
            .FirstOrDefault(r => r.Key.StartsWith("2"))
            .Value;

        if (successResponse?.Content == null || successResponse.Content.Count == 0)
        {
            return "IActionResult";
        }

        // Get the response schema
        var mediaType = successResponse.Content.FirstOrDefault().Value;
        if (mediaType?.Schema == null)
        {
            return "IActionResult";
        }

        var responseType = MapOpenApiTypeToCSharp(mediaType.Schema, false);
        return $"ActionResult<{responseType}>";
    }

    private string GetParameterType(IOpenApiParameter parameter)
    {
        if (parameter.Schema == null)
            return "string";

        var type = MapOpenApiTypeToCSharp(parameter.Schema, !parameter.Required);
        return type;
    }

    private static string GetParameterAttribute(ControllerParameterSource source)
    {
        return source switch
        {
            ControllerParameterSource.Path => "[FromRoute] ",
            ControllerParameterSource.Header => "[FromHeader] ",
            ControllerParameterSource.Query => "[FromQuery] ",
            ControllerParameterSource.Body => "[FromBody] ",
            _ => ""
        };
    }

    private string GetRequestBodyType(IOpenApiRequestBody requestBody, OpenApiDocument _)
    {
        if (requestBody.Content == null || requestBody.Content.Count == 0)
            return "object";

        var mediaType = requestBody.Content.FirstOrDefault().Value;
        if (mediaType?.Schema == null)
            return "object";

        return MapOpenApiTypeToCSharp(mediaType.Schema, !requestBody.Required);
    }

    private string ConvertPathToRouteTemplate(string openApiPath)
    {
        // Convertit /users/{id} en users/{id}
        return openApiPath.TrimStart('/');
    }

    private static string MapOpenApiTypeToCSharp(IOpenApiSchema schema, bool nullable)
    {
        var types = GetSchemaTypes(schema);

        // Si "null" est présent dans les types, on rend le type nullable
        var hasNull = types.Contains("null");
        if (hasNull)
        {
            nullable = true;
            types = types.Where(t => t != "null").ToList();
        }

        // Si aucun type après filtrage de "null", on retourne object?
        if (types.Count == 0)
        {
            return "object?";
        }

        // On prend le premier type non-null pour la conversion
        var primaryType = types.First();

        switch (primaryType)
        {
            // Array
            case "array":
            {
                var itemType = schema.Items != null
                    ? MapOpenApiTypeToCSharp(schema.Items, false)
                    : "object";
                return $"ICollection<{itemType}>";
            }
            // Object
            case "object" when schema.AdditionalProperties != null:
            {
                var valueType = MapOpenApiTypeToCSharp(schema.AdditionalProperties, false);
                return $"IDictionary<string, {valueType}>";
            }
            case "object":
                return nullable ? "object?" : "object";
        }

        // Types primitifs
        var baseType = primaryType switch
        {
            "integer" when schema.Format == "int64" => "long",
            "integer" => "int",
            "number" when schema.Format == "float" => "float",
            "number" when schema.Format == "double" => "double",
            "number" => "decimal",
            "string" when schema.Format == "date" => "DateOnly",
            "string" when schema.Format == "date-time" => "DateTime",
            "string" when schema.Format == "uuid" => "Guid",
            "string" when schema.Format == "byte" => "byte[]",
            "string" => "string",
            "boolean" => "bool",
            _ => "object"
        };

        // Nullable pour types valeur
        if (nullable && baseType != "string" && baseType != "object" && !baseType.Contains('['))
        {
            return $"{baseType}?";
        }

        return baseType;
    }

    private static List<string> GetSchemaTypes(IOpenApiSchema schema)
    {
        var types = new List<string>();

        // En OpenAPI 3.1, le type peut être un JsonSchemaType qui supporte plusieurs valeurs
        // JsonSchemaType est un enum avec [Flags] qui peut contenir plusieurs types
        var schemaType = schema.Type;

        if (schemaType.HasValue && schemaType.Value != 0)
        {
            // Vérifie chaque flag possible
            if (schemaType.Value.HasFlag(JsonSchemaType.Null))
                types.Add("null");
            if (schemaType.Value.HasFlag(JsonSchemaType.Boolean))
                types.Add("boolean");
            if (schemaType.Value.HasFlag(JsonSchemaType.Integer))
                types.Add("integer");
            if (schemaType.Value.HasFlag(JsonSchemaType.Number))
                types.Add("number");
            if (schemaType.Value.HasFlag(JsonSchemaType.String))
                types.Add("string");
            if (schemaType.Value.HasFlag(JsonSchemaType.Array))
                types.Add("array");
            if (schemaType.Value.HasFlag(JsonSchemaType.Object))
                types.Add("object");
        }

        // Fallback: si aucun type n'est défini, on inspecte les propriétés du schéma
        if (types.Count != 0) return types;
        if (schema.Properties is { Count: > 0 })
        {
            types.Add("object");
        }
        else if (schema.Items != null)
        {
            types.Add("array");
        }

        return types;
    }

    private static string SanitizeName(string name, bool pascalCase = false)
    {
        if (string.IsNullOrWhiteSpace(name))
            return "Unnamed";

        var sanitized = new StringBuilder();
        var nextUpper = pascalCase;

        foreach (var c in name)
        {
            if (char.IsLetterOrDigit(c))
            {
                sanitized.Append(nextUpper ? char.ToUpper(c) : c);
                nextUpper = false;
            }
            else if (c is '_' or '-' or '.' or ' ')
            {
                nextUpper = true;
            }
        }

        var result = sanitized.ToString();

        if (result.Length == 0 || !char.IsLetter(result[0]))
            result = "Action" + result;

        return result;
    }

    private static string EscapeXmlComment(string comment)
    {
        return comment
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;")
            .Replace("\"", "&quot;")
            .Replace("'", "&apos;");
    }
}
