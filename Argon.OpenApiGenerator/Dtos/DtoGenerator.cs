using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.OpenApi;

namespace Argon.OpenApiGenerator.Dtos;

/// <summary>
/// Générateur de DTOs à partir de schémas OpenAPI.
/// </summary>
public class DtoGenerator
{
    private readonly GeneratorConfiguration _configuration;

    public DtoGenerator(GeneratorConfiguration configuration)
    {
        _configuration = configuration;
    }

    public string Generate(OpenApiDocument document, string fileName)
    {
        if (document.Components?.Schemas == null || document.Components.Schemas.Count == 0)
            return string.Empty;

        var sb = new StringBuilder();
        
        // Header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        
        // Usings
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        
        if (_configuration.GenerateValidationAttributes)
        {
            sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        }
        
        sb.AppendLine();
        
        // Namespace
        var fullNamespace = string.IsNullOrWhiteSpace(_configuration.BaseNamespace) 
            ? _configuration.DtosNamespace 
            : $"{_configuration.BaseNamespace}.{_configuration.DtosNamespace}";
        
        sb.AppendLine($"namespace {fullNamespace};");
        sb.AppendLine();

        // Génère chaque schéma
        foreach (var schema in document.Components.Schemas)
        {
            GenerateSchema(sb, schema.Key, schema.Value);
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private void GenerateSchema(StringBuilder sb, string schemaName, IOpenApiSchema schema)
    {
        // XML Documentation
        if (_configuration.GenerateXmlDocumentation && !string.IsNullOrWhiteSpace(schema.Description))
        {
            sb.AppendLine("/// <summary>");
            sb.AppendLine($"/// {EscapeXmlComment(schema.Description) ?? "No description provided."}");
            sb.AppendLine("/// </summary>");
        }

        // Type déclaration
        var keyword = _configuration.UseRecords ? "record" : "class";
        sb.AppendLine($"public {keyword} {SanitizeName(schemaName)}");
        sb.AppendLine("{");

        // Propriétés
        if (schema.Properties != null)
        {
            foreach (var property in schema.Properties)
            {
                GenerateProperty(sb, property.Key, property.Value, schema.Required?.Contains(property.Key) ?? false);
            }
        }

        sb.AppendLine("}");
    }

    private void GenerateProperty(StringBuilder sb, string propertyName, IOpenApiSchema propertySchema, bool isRequired)
    {
        const string indent = "    ";

        // XML Documentation
        if (_configuration.GenerateXmlDocumentation && !string.IsNullOrWhiteSpace(propertySchema.Description))
        {
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// {EscapeXmlComment(propertySchema.Description) ?? "No description provided."}");
            sb.AppendLine($"{indent}/// </summary>");
        }

        // Validation attributes
        if (_configuration.GenerateValidationAttributes)
        {
            if (isRequired)
            {
                sb.AppendLine($"{indent}[Required]");
            }

            if (propertySchema.MinLength.HasValue || propertySchema.MaxLength.HasValue)
            {
                var min = propertySchema.MinLength ?? 0;
                var max = propertySchema.MaxLength.HasValue ? propertySchema.MaxLength.ToString() : "int.MaxValue";
                sb.AppendLine($"{indent}[StringLength({max}, MinimumLength = {min})]");
            }

            if (propertySchema.Minimum is not null && propertySchema.Maximum is not null)
            {
                sb.AppendLine($"{indent}[Range({propertySchema.Minimum}, {propertySchema.Maximum})]");
            }
            else if (propertySchema.Maximum is not null)
            {
                sb.AppendLine($"{indent}[Range(double.MinValue, {propertySchema.Maximum})]");
            }
            else if (propertySchema.Minimum is not null)
            {
                sb.AppendLine($"{indent}[Range({propertySchema.Minimum}, double.MaxValue)]");
            }

            if (propertySchema.Pattern != null)
            {
                sb.AppendLine($"{indent}[RegularExpression(@\"{propertySchema.Pattern}\")]");
            }
        }

        // Type et nom de propriété
        var csharpType = TypeUtils.DetermineFinalType(propertySchema);
        var sanitizedName = SanitizeName(propertyName, pascalCase: true);
        var requiredModifier = isRequired ? "required " : string.Empty;
        
        sb.AppendLine($"{indent}public {requiredModifier}{csharpType} {sanitizedName} {{ get; set; }}");
        sb.AppendLine();
    }

    private static string MapOpenApiTypeToCSharp(IOpenApiSchema schema, bool nullable)
    {
        var types = GetSchemaTypes(schema);

        // Si "null" est présent dans les types, on rend le type nullable
        var hasNull = types.Contains("null");
        if (hasNull)
        {
            nullable = true;
            types = types.Where(t => t != "null").ToList();
        }

        // Si aucun type après filtrage de "null", on retourne object?
        if (types.Count == 0)
        {
            return "object?";
        }

        // On prend le premier type non-null pour la conversion
        var primaryType = types.First();

        switch (primaryType)
        {
            // Array
            case "array":
            {
                var itemType = schema.Items != null
                    ? MapOpenApiTypeToCSharp(schema.Items, false)
                    : "object";
                return $"ICollection<{itemType}>";
            }
            // Object
            case "object" when schema.AdditionalProperties != null:
            {
                var valueType = MapOpenApiTypeToCSharp(schema.AdditionalProperties, false);
                return $"IDictionary<string, {valueType}>";
            }
            case "object":
                return nullable ? "object?" : "object";
        }

        // Types primitifs
        var baseType = primaryType switch
        {
            "integer" when schema.Format == "int64" => "long",
            "integer" => "int",
            "number" when schema.Format == "float" => "float",
            "number" when schema.Format == "double" => "double",
            "number" => "decimal",
            "string" when schema.Format == "date" => "DateOnly",
            "string" when schema.Format == "date-time" => "DateTime",
            "string" when schema.Format == "uuid" => "Guid",
            "string" when schema.Format == "byte" => "byte[]",
            "string" => "string",
            "boolean" => "bool",
            _ => "object"
        };

        // Nullable pour types valeur
        if (nullable && baseType != "string" && baseType != "object" && !baseType.Contains('['))
        {
            return $"{baseType}?";
        }

        return baseType;
    }

    private static List<string> GetSchemaTypes(IOpenApiSchema schema)
    {
        var types = new List<string>();

        // En OpenAPI 3.1, le type peut être un JsonSchemaType qui supporte plusieurs valeurs
        // JsonSchemaType est un enum avec [Flags] qui peut contenir plusieurs types
        var schemaType = schema.Type;

        if (schemaType.HasValue && schemaType.Value != 0)
        {
            // Vérifie chaque flag possible
            if (schemaType.Value.HasFlag(JsonSchemaType.Null))
                types.Add("null");
            if (schemaType.Value.HasFlag(JsonSchemaType.Boolean))
                types.Add("boolean");
            if (schemaType.Value.HasFlag(JsonSchemaType.Integer))
                types.Add("integer");
            if (schemaType.Value.HasFlag(JsonSchemaType.Number))
                types.Add("number");
            if (schemaType.Value.HasFlag(JsonSchemaType.String))
                types.Add("string");
            if (schemaType.Value.HasFlag(JsonSchemaType.Array))
                types.Add("array");
            if (schemaType.Value.HasFlag(JsonSchemaType.Object))
                types.Add("object");
        }

        // Fallback: si aucun type n'est défini, on inspecte les propriétés du schéma
        if (types.Count != 0) return types;
        if (schema.Properties is { Count: > 0 })
        {
            types.Add("object");
        }
        else if (schema.Items != null)
        {
            types.Add("array");
        }

        return types;
    }

    private static string SanitizeName(string name, bool pascalCase = false)
    {
        if (string.IsNullOrWhiteSpace(name))
            return "UnnamedProperty";

        // Remplace les caractères invalides
        var sanitized = new StringBuilder();
        bool nextUpper = pascalCase;

        foreach (var c in name)
        {
            if (char.IsLetterOrDigit(c))
            {
                sanitized.Append(nextUpper ? char.ToUpper(c) : c);
                nextUpper = false;
            }
            else if (c == '_' || c == '-' || c == '.' || c == ' ')
            {
                nextUpper = true;
            }
        }

        var result = sanitized.ToString();
        
        // Ensure the name starts with a letter
        if (result.Length == 0 || !char.IsLetter(result[0]))
            result = "Property" + result;

        return result;
    }

    private static string? EscapeXmlComment(string? comment)
    {
        return comment?
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;")
            .Replace("\"", "&quot;")
            .Replace("'", "&apos;");
    }
}
