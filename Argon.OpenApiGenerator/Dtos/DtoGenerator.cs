using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json.Nodes;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.OpenApi;

namespace Argon.OpenApiGenerator.Dtos;

/// <summary>
/// Generates C# DTOs from OpenAPI schema definitions.
/// </summary>
internal sealed class DtoGenerator
{
    private readonly GeneratorConfiguration _configuration;

    public DtoGenerator(GeneratorConfiguration configuration)
    {
        _configuration = configuration;
    }

    #region Public Methods

    /// <summary>
    /// Generates DTO code from an OpenAPI document.
    /// </summary>
    /// <param name="document">The OpenAPI document containing schemas.</param>
    /// <param name="context">The source production context.</param>
    public void Generate(OpenApiDocument document, SourceProductionContext context)
    {
        if (document.Components?.Schemas == null || document.Components.Schemas.Count == 0)
        {
            return;
        }

        foreach (var schema in document.Components.Schemas)
        {
            var sb = new StringBuilder();

            AppendFileHeader(sb);
            AppendUsings(sb);
            AppendNamespace(sb);

            if (IsEnumSchema(schema.Value))
            {
                GenerateEnum(sb, schema.Key, schema.Value);
            }
            else
            {
                GenerateSchema(sb, schema.Key, schema.Value);
            }

            var sanitizedName = SanitizeName(schema.Key);
            context.AddSource(
                $"{sanitizedName}.g.cs",
                SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    #endregion

    #region File Structure Generation

    /// <summary>
    /// Appends the file header with auto-generated marker and nullable enable directive.
    /// </summary>
    private static void AppendFileHeader(StringBuilder sb)
    {
        sb.AppendLine(Constants.CodeGeneration.AutoGeneratedHeader);
        sb.AppendLine(Constants.CodeGeneration.NullableDirective);
        sb.AppendLine();
    }

    /// <summary>
    /// Appends the required using statements.
    /// </summary>
    private void AppendUsings(StringBuilder sb)
    {
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");

        if (_configuration.GenerateValidationAttributes)
        {
            sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        }

        sb.AppendLine();
    }

    /// <summary>
    /// Appends the namespace declaration.
    /// </summary>
    private void AppendNamespace(StringBuilder sb)
    {
        var fullNamespace = string.IsNullOrWhiteSpace(_configuration.BaseNamespace)
            ? _configuration.DtosNamespace
            : $"{_configuration.BaseNamespace}.{_configuration.DtosNamespace}";

        sb.AppendLine($"namespace {fullNamespace};");
        sb.AppendLine();
    }

    #endregion

    #region Schema Generation

    /// <summary>
    /// Determines if a schema represents an enum.
    /// </summary>
    private static bool IsEnumSchema(IOpenApiSchema schema)
    {
        return schema.Enum is { Count: > 0 } &&
               schema.Type?.HasFlag(JsonSchemaType.String) == true;
    }

    /// <summary>
    /// Generates an enum from a schema.
    /// </summary>
    private void GenerateEnum(StringBuilder sb, string enumName, IOpenApiSchema schema)
    {
        AppendSchemaDocumentation(sb, schema);
        sb.AppendLine($"public enum {SanitizeName(enumName)}");
        sb.AppendLine("{");

        var enumValues = schema.Enum?.ToList() ?? new List<JsonNode>();
        for (var i = 0; i < enumValues.Count; i++)
        {
            var value = enumValues[i].ToString();
            var isLast = i == enumValues.Count - 1;

            if (_configuration.GenerateXmlDocumentation && !string.IsNullOrWhiteSpace(value))
            {
                sb.AppendLine($"{Constants.CodeGeneration.Indent}/// <summary>");
                sb.AppendLine($"{Constants.CodeGeneration.Indent}/// {EscapeXmlComment(value)}");
                sb.AppendLine($"{Constants.CodeGeneration.Indent}/// </summary>");
            }

            var enumMemberName = SanitizeEnumMemberName(value);
            sb.AppendLine($"{Constants.CodeGeneration.Indent}{enumMemberName}{(isLast ? string.Empty : ",")}");
        }

        sb.AppendLine("}");
    }

    /// <summary>
    /// Generates a single schema (class or record).
    /// </summary>
    private void GenerateSchema(StringBuilder sb, string schemaName, IOpenApiSchema schema)
    {
        AppendSchemaDocumentation(sb, schema);
        AppendSchemaDeclaration(sb, schemaName);
        AppendSchemaProperties(sb, schema);
        sb.AppendLine("}");
    }

    /// <summary>
    /// Appends XML documentation for a schema.
    /// </summary>
    private void AppendSchemaDocumentation(StringBuilder sb, IOpenApiSchema schema)
    {
        if (!_configuration.GenerateXmlDocumentation || string.IsNullOrWhiteSpace(schema.Description))
        {
            return;
        }

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// {EscapeXmlComment(schema.Description)}");
        sb.AppendLine("/// </summary>");
    }

    /// <summary>
    /// Appends the schema declaration (class or record).
    /// </summary>
    private void AppendSchemaDeclaration(StringBuilder sb, string schemaName)
    {
        var keyword = _configuration.UseRecords ? "record" : "class";
        sb.AppendLine($"public {keyword} {SanitizeName(schemaName)}");
        sb.AppendLine("{");
    }

    /// <summary>
    /// Appends all properties of a schema.
    /// </summary>
    private void AppendSchemaProperties(StringBuilder sb, IOpenApiSchema schema)
    {
        if (schema.Properties == null)
        {
            return;
        }

        foreach (var property in schema.Properties)
        {
            var isRequired = (schema.Required?.Contains(property.Key) ?? false) || !TypeUtils.IsNullableType(property.Value);
            GenerateProperty(sb, property.Key, property.Value, isRequired);
        }
    }

    /// <summary>
    /// Generates a single property with documentation and validation attributes.
    /// </summary>
    private void GenerateProperty(StringBuilder sb, string propertyName, IOpenApiSchema propertySchema, bool isRequired)
    {
        AppendPropertyDocumentation(sb, propertySchema);
        AppendValidationAttributes(sb, propertySchema, isRequired);
        AppendPropertyDeclaration(sb, propertyName, propertySchema, isRequired);
    }

    #endregion

    #region Documentation and Attributes

    /// <summary>
    /// Appends XML documentation for a property.
    /// </summary>
    private void AppendPropertyDocumentation(StringBuilder sb, IOpenApiSchema propertySchema)
    {
        if (!_configuration.GenerateXmlDocumentation || string.IsNullOrWhiteSpace(propertySchema.Description))
        {
            return;
        }

        sb.AppendLine($"{Constants.CodeGeneration.Indent}/// <summary>");
        sb.AppendLine($"{Constants.CodeGeneration.Indent}/// {EscapeXmlComment(propertySchema.Description)}");
        sb.AppendLine($"{Constants.CodeGeneration.Indent}/// </summary>");
    }

    /// <summary>
    /// Appends validation attributes for a property.
    /// </summary>
    private void AppendValidationAttributes(StringBuilder sb, IOpenApiSchema propertySchema, bool isRequired)
    {
        if (!_configuration.GenerateValidationAttributes)
        {
            return;
        }

        if (isRequired)
        {
            sb.AppendLine($"{Constants.CodeGeneration.Indent}[Required]");
        }

        AppendStringLengthAttribute(sb, propertySchema);
        AppendRangeAttribute(sb, propertySchema);
        AppendPatternAttribute(sb, propertySchema);
    }

    /// <summary>
    /// Appends the StringLength validation attribute if applicable.
    /// </summary>
    private static void AppendStringLengthAttribute(StringBuilder sb, IOpenApiSchema propertySchema)
    {
        if (!propertySchema.MinLength.HasValue && !propertySchema.MaxLength.HasValue)
        {
            return;
        }

        var min = propertySchema.MinLength ?? 0;
        var max = propertySchema.MaxLength?.ToString() ?? "int.MaxValue";
        sb.AppendLine($"{Constants.CodeGeneration.Indent}[StringLength({max}, MinimumLength = {min})]");
    }

    /// <summary>
    /// Appends the Range validation attribute if applicable.
    /// </summary>
    private static void AppendRangeAttribute(StringBuilder sb, IOpenApiSchema propertySchema)
    {
        if (propertySchema.Minimum is null && propertySchema.Maximum is null)
        {
            return;
        }

        var min = propertySchema.Minimum is not null ? $"{propertySchema.Minimum}" : "double.MinValue";
        var max = propertySchema.Maximum is not null ? $"{propertySchema.Maximum}" : "double.MaxValue";
        sb.AppendLine($"{Constants.CodeGeneration.Indent}[Range({min}, {max})]");
    }

    /// <summary>
    /// Appends the RegularExpression validation attribute if applicable.
    /// </summary>
    private static void AppendPatternAttribute(StringBuilder sb, IOpenApiSchema propertySchema)
    {
        if (propertySchema.Pattern == null)
        {
            return;
        }

        sb.AppendLine($"{Constants.CodeGeneration.Indent}[RegularExpression(@\"{propertySchema.Pattern}\")]");
    }

    /// <summary>
    /// Appends the property declaration.
    /// </summary>
    private static void AppendPropertyDeclaration(StringBuilder sb, string propertyName, IOpenApiSchema propertySchema, bool isRequired)
    {
        var csharpType = TypeUtils.DetermineFinalType(propertySchema);
        var sanitizedName = SanitizeName(propertyName, pascalCase: true);
        var requiredModifier = isRequired ? "required " : string.Empty;

        sb.AppendLine($"{Constants.CodeGeneration.Indent}public {requiredModifier}{csharpType} {sanitizedName} {{ get; set; }}");
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Sanitizes a name to be a valid C# identifier, optionally converting to PascalCase.
    /// </summary>
    private static string SanitizeName(string name, bool pascalCase = false)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            return "UnnamedProperty";
        }

        var sanitized = new StringBuilder();
        var nextUpper = pascalCase;

        foreach (var c in name)
        {
            if (char.IsLetterOrDigit(c))
            {
                sanitized.Append(nextUpper ? char.ToUpper(c) : c);
                nextUpper = false;
            }
            else if (c is '_' or '-' or '.' or ' ')
            {
                nextUpper = true;
            }
        }

        var result = sanitized.ToString();

        // Ensure the name starts with a letter
        if (result.Length == 0 || !char.IsLetter(result[0]))
        {
            result = "Property" + result;
        }

        return result;
    }

    /// <summary>
    /// Sanitizes an enum member name to be a valid C# identifier in PascalCase.
    /// </summary>
    private static string SanitizeEnumMemberName(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            return "Unknown";
        }

        var sanitized = new StringBuilder();
        var nextUpper = true;

        foreach (var c in name)
        {
            if (char.IsLetterOrDigit(c))
            {
                sanitized.Append(nextUpper ? char.ToUpper(c) : c);
                nextUpper = false;
            }
            else if (c is '_' or '-' or '.' or ' ')
            {
                nextUpper = true;
            }
        }

        var result = sanitized.ToString();

        // Ensure the name starts with a letter
        if (result.Length == 0 || !char.IsLetter(result[0]))
        {
            result = "Value" + result;
        }

        return result;
    }

    /// <summary>
    /// Escapes special XML characters in a comment.
    /// </summary>
    private static string EscapeXmlComment(string? comment)
    {
        if (comment == null)
        {
            return string.Empty;
        }

        return comment
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;")
            .Replace("\"", "&quot;")
            .Replace("'", "&apos;");
    }

    #endregion
}
