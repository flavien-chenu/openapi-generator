using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.OpenApi;

namespace TeknixIT.OpenApiGenerator.Server.Controllers;

/// <summary>
/// Generator for ASP.NET Core controllers from OpenAPI paths.
/// </summary>
internal sealed class ControllerGenerator
{
    private readonly GeneratorConfiguration _configuration;

    public ControllerGenerator(GeneratorConfiguration configuration)
    {
        _configuration = configuration;
    }

    #region Public Methods

    /// <summary>
    /// Generates controller code from an OpenAPI document.
    /// </summary>
    /// <param name="document">The OpenAPI document.</param>
    /// <param name="context">The source production context.</param>
    public void Generate(OpenApiDocument document, SourceProductionContext context)
    {
        if (document.Paths.Count == 0)
        {
            return;
        }

        var controllerGroups = GroupPathsByController(document.Paths);
        var definitions = controllerGroups
            .Select(group => GetDefinition(group.Key, group.Value, document))
            .ToList();

        foreach (var definition in definitions)
        {
            var sb = new StringBuilder();

            AppendFileHeader(sb);
            AppendUsings(sb);
            AppendNamespace(sb);
            GenerateController(sb, definition);

            context.AddSource(
                $"{definition.Name}Controller.g.cs",
                SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    #endregion

    #region File Structure Generation

    /// <summary>
    /// Appends the file header with auto-generated marker and nullable enable directive.
    /// </summary>
    private static void AppendFileHeader(StringBuilder sb)
    {
        sb.AppendLine(Constants.CodeGeneration.AutoGeneratedHeader);
        sb.AppendLine(Constants.CodeGeneration.NullableDirective);
        sb.AppendLine();
    }

    /// <summary>
    /// Appends the required using statements.
    /// </summary>
    private void AppendUsings(StringBuilder sb)
    {
        var dtosNamespace = string.IsNullOrWhiteSpace(_configuration.BaseNamespace)
            ? _configuration.ContractsNamespace
            : $"{_configuration.BaseNamespace}.{_configuration.ContractsNamespace}";
        var controllerBaseNamespaceComponents = _configuration.ControllerBaseClass.Split('.');
        var controllerBaseNamespace = string.Join(".", controllerBaseNamespaceComponents.Take(controllerBaseNamespaceComponents.Length - 1));

        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.AspNetCore.Mvc;");
        sb.AppendLine($"using {dtosNamespace};");

        if (!string.IsNullOrWhiteSpace(controllerBaseNamespace) && controllerBaseNamespace != _configuration.ControllersNamespace)
        {
            sb.AppendLine($"using {controllerBaseNamespace};");
        }

        sb.AppendLine();
    }

    /// <summary>
    /// Appends the namespace declaration.
    /// </summary>
    private void AppendNamespace(StringBuilder sb)
    {
        var fullNamespace = string.IsNullOrWhiteSpace(_configuration.BaseNamespace)
            ? _configuration.ControllersNamespace
            : $"{_configuration.BaseNamespace}.{_configuration.ControllersNamespace}";

        sb.AppendLine($"namespace {fullNamespace};");
        sb.AppendLine();
    }

    #endregion

    /// <summary>
    /// Groups paths by controller based on the configured grouping strategy.
    /// </summary>
    private Dictionary<string, List<(string Path, IOpenApiPathItem PathItem)>> GroupPathsByController(
        OpenApiPaths paths)
    {
        var groups = new Dictionary<string, List<(string, IOpenApiPathItem)>>();

        foreach (var path in paths)
        {
            if (path.Value.Operations is null || path.Value.Operations.Count == 0)
            {
                continue;
            }

            var controllerName = GetControllerName(path.Key, path.Value);

            if (!groups.ContainsKey(controllerName))
            {
                groups[controllerName] = [];
            }

            groups[controllerName].Add((path.Key, path.Value));
        }

        return groups;
    }

    /// <summary>
    /// Determines the controller name from a path and its operations based on the configured strategy.
    /// </summary>
    private string GetControllerName(string pathKey, IOpenApiPathItem pathItem)
    {
        return _configuration.ControllerGroupingStrategy switch
        {
            ControllerGroupingStrategy.ByTag => GetControllerNameByTag(pathKey, pathItem),
            ControllerGroupingStrategy.ByFirstPathSegment => GetControllerNameByFirstSegment(pathKey),
            ControllerGroupingStrategy.ByPath => GetControllerNameByPath(pathKey),
            _ => GetControllerNameByTag(pathKey, pathItem)
        };
    }

    /// <summary>
    /// Gets the controller name using the tag from the first operation.
    /// Falls back to first path segment if no tag is found.
    /// </summary>
    private static string GetControllerNameByTag(string pathKey, IOpenApiPathItem pathItem)
    {
        // Use the tag from the first operation
        var firstOperation = pathItem.Operations?.FirstOrDefault().Value;
        if (firstOperation?.Tags is { Count: > 0 })
        {
            var tagName = firstOperation.Tags.First()?.Name;
            if (tagName is not null && !string.IsNullOrWhiteSpace(tagName))
            {
                return SanitizeName(tagName, pascalCase: true);
            }
        }

        // Fallback: use the first segment of the path
        return GetControllerNameByFirstSegment(pathKey);
    }

    /// <summary>
    /// Gets the controller name from the first segment of the path.
    /// </summary>
    private static string GetControllerNameByFirstSegment(string pathKey)
    {
        var segments = pathKey.Split(['/'], StringSplitOptions.RemoveEmptyEntries);
        return segments.Length > 0
            ? SanitizeName(segments[0], pascalCase: true)
            : "Default";
    }

    /// <summary>
    /// Gets the controller name from the full path (excluding parameters).
    /// </summary>
    private static string GetControllerNameByPath(string pathKey)
    {
        // Remove leading/trailing slashes and replace path separators with underscores
        var cleanPath = pathKey.Trim('/');
        
        // Remove path parameters (e.g., {id}) and replace remaining slashes
        var segments = cleanPath.Split(['/'], StringSplitOptions.RemoveEmptyEntries);
        var sanitizedSegments = segments
            .Where(s => !s.StartsWith("{") || !s.EndsWith("}"))
            .Select(s => SanitizeName(s, pascalCase: true));
        
        var name = string.Join("", sanitizedSegments);
        return !string.IsNullOrWhiteSpace(name) ? name : "Default";
    }

    /// <summary>
    /// Creates a controller definition from a group of paths.
    /// </summary>
    private ControllerDefinition GetDefinition(
        string controllerName,
        List<(string Path, IOpenApiPathItem PathItem)> paths,
        OpenApiDocument document)
    {
        var definition = new ControllerDefinition(controllerName)
        {
            Route = GetCommonPathPrefix([.. paths.Select(p => p.Path)]),
            Documentation = $"Controller for {controllerName}",
        };

        definition.Methods = GetMethodsDefinition(definition, paths, document);

        return definition;
    }

    /// <summary>
    /// Creates method definitions for all operations in the given paths.
    /// </summary>
    private List<ControllerMethodDefinition> GetMethodsDefinition(
        ControllerDefinition controller,
        List<(string Path, IOpenApiPathItem PathItem)> paths,
        OpenApiDocument document)
    {
        var methods = new List<ControllerMethodDefinition>();

        foreach (var (path, pathItem) in paths)
        {
            foreach (var operation in pathItem.Operations ?? [])
            {
                methods.Add(GetMethodDefinition(controller, operation.Key, operation.Value, path, document));
            }
        }

        return methods;
    }

    /// <summary>
    /// Creates a method definition from an OpenAPI operation.
    /// </summary>
    private static ControllerMethodDefinition GetMethodDefinition(
        ControllerDefinition controller,
        HttpMethod httpMethod,
        OpenApiOperation operation,
        string path,
        OpenApiDocument document)
    {
        var route = path.Replace(controller.Route, string.Empty);
        if (controller.Route.Length > 0)
        {
            route = ConvertPathToRouteTemplate(route);
        }

        var methodDefinition = new ControllerMethodDefinition
        {
            Name = GetMethodName(operation, path, httpMethod),
            HttpMethod = httpMethod,
            Route = route,
            Documentation = operation.Summary ?? operation.Description ?? "No description available.",
            ReturnType = "IActionResult",
            Deprecated = operation.Deprecated
        };

        AddOperationParameters(methodDefinition, operation);
        AddRequestBodyParameter(methodDefinition, operation, document);

        // Sort parameters according to C# conventions (required before optional, etc.)
        methodDefinition.Parameters = SortParametersByRequirement(methodDefinition.Parameters);

        return methodDefinition;
    }

    /// <summary>
    /// Adds operation parameters to the method definition.
    /// </summary>
    private static void AddOperationParameters(ControllerMethodDefinition methodDefinition, OpenApiOperation operation)
    {
        if (operation.Parameters == null)
        {
            return;
        }

        var i = 0;
        foreach (var param in operation.Parameters)
        {
            methodDefinition.Parameters.Add(new ControllerParameterDefinition
            {
                Name = SanitizeName(param.Name ?? $"param{i}"),
                Type = GetParameterType(param),
                Documentation = param.Description ?? string.Empty,
                Source = MapParameterLocation(param.In),
                IsRequired = param.Required || param.In is ParameterLocation.Path,
                DefaultValue = param.Schema?.Default?.ToString()
            });
            i++;
        }
    }

    /// <summary>
    /// Adds request body parameter to the method definition if present.
    /// </summary>
    private static void AddRequestBodyParameter(ControllerMethodDefinition methodDefinition, OpenApiOperation operation, OpenApiDocument document)
    {
        if (operation.RequestBody == null)
        {
            return;
        }

        methodDefinition.Parameters.Add(new ControllerParameterDefinition
        {
            Name = "request",
            Type = GetRequestBodyType(operation.RequestBody, document),
            Source = ControllerParameterSource.Body,
            IsRequired = operation.RequestBody.Required,
            Documentation = operation.RequestBody.Description ?? string.Empty,
        });
    }

    /// <summary>
    /// Maps OpenAPI parameter location to controller parameter source.
    /// </summary>
    private static ControllerParameterSource MapParameterLocation(ParameterLocation? location)
    {
        return location switch
        {
            ParameterLocation.Query => ControllerParameterSource.Query,
            ParameterLocation.Header => ControllerParameterSource.Header,
            ParameterLocation.Path => ControllerParameterSource.Path,
            _ => ControllerParameterSource.Default
        };
    }

    /// <summary>
    /// Generates a controller class from a controller definition.
    /// </summary>
    private void GenerateController(StringBuilder sb, ControllerDefinition definition)
    {
        AppendControllerDocumentation(sb, definition);
        AppendControllerAttributes(sb, definition);
        AppendControllerDeclaration(sb, definition);
        AppendControllerMethods(sb, definition);
        sb.AppendLine("}");
    }

    /// <summary>
    /// Appends XML documentation for a controller.
    /// </summary>
    private void AppendControllerDocumentation(StringBuilder sb, ControllerDefinition definition)
    {
        if (!_configuration.GenerateXmlDocumentation)
        {
            return;
        }

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// {EscapeXmlComment(definition.Documentation)}");
        sb.AppendLine("/// </summary>");
    }

    /// <summary>
    /// Appends controller attributes.
    /// </summary>
    private void AppendControllerAttributes(StringBuilder sb, ControllerDefinition definition)
    {
        if (_configuration.AddApiControllerAttribute)
        {
            sb.AppendLine("[ApiController]");
        }

        if (!string.IsNullOrEmpty(definition.Route))
        {
            sb.AppendLine($"[Route(\"{definition.Route}\")]");
        }
    }

    /// <summary>
    /// Appends controller class declaration.
    /// </summary>
    private void AppendControllerDeclaration(StringBuilder sb, ControllerDefinition definition)
    {
        sb.AppendLine($"public abstract class {definition.Name}ControllerBase : {_configuration.ControllerBaseClass.Split('.').Last()}");
        sb.AppendLine("{");
    }

    /// <summary>
    /// Appends all controller methods.
    /// </summary>
    private void AppendControllerMethods(StringBuilder sb, ControllerDefinition definition)
    {
        foreach (var method in definition.Methods)
        {
            GenerateControllerMethod(sb, method);
            sb.AppendLine();
        }
    }

    /// <summary>
    /// Gets the common path prefix from a list of paths.
    /// </summary>
    private static string GetCommonPathPrefix(List<string> paths)
    {
        if (paths.Count == 0)
        {
            return string.Empty;
        }

        if (paths.Count == 1)
        {
            // For a single path, take everything except the last segment
            var segments = paths[0].Split(['/'], StringSplitOptions.RemoveEmptyEntries);
            if (segments.Length <= 1)
            {
                return string.Empty;
            }
            return "/" + string.Join("/", segments.Take(segments.Length - 1));
        }

        // Split all paths into segments
        var allSegments = paths
            .Select(p => p.Split(['/'], StringSplitOptions.RemoveEmptyEntries).ToList())
            .ToList();

        var minSegments = allSegments.Min(s => s.Count);
        if (minSegments == 0)
        {
            return string.Empty;
        }

        var commonSegments = new List<string>();

        // Compare segment by segment
        for (var i = 0; i < minSegments; i++)
        {
            var firstSegment = allSegments[0][i];

            // Stop if segment is a parameter
            if (firstSegment.Contains("{"))
            {
                break;
            }

            // Check if all paths have the same segment at this position
            if (allSegments.All(segments => segments[i] == firstSegment))
            {
                commonSegments.Add(firstSegment);
            }
            else
            {
                break;
            }
        }

        return commonSegments.Count > 0
            ? "/" + string.Join("/", commonSegments)
            : string.Empty;
    }

    /// <summary>
    /// Generates a controller method from a method definition.
    /// </summary>
    private void GenerateControllerMethod(StringBuilder sb, ControllerMethodDefinition method)
    {
        const string indent = "    ";

        AppendMethodDocumentation(sb, method, indent);
        AppendHttpMethodAttribute(sb, method, indent);
        AppendMethodSignature(sb, method, indent);
    }

    /// <summary>
    /// Appends XML documentation for a method.
    /// </summary>
    private void AppendMethodDocumentation(StringBuilder sb, ControllerMethodDefinition method, string indent)
    {
        if (!_configuration.GenerateXmlDocumentation)
        {
            return;
        }

        var description = string.IsNullOrWhiteSpace(method.Documentation)
            ? "No description available."
            : method.Documentation;

        sb.AppendLine($"{indent}/// <summary>");
        sb.AppendLine($"{indent}/// {EscapeXmlComment(description)}");
        sb.AppendLine($"{indent}/// </summary>");

        foreach (var param in method.Parameters)
        {
            sb.AppendLine($"{indent}/// <param name=\"{SanitizeName(param.Name)}\">{EscapeXmlComment(param.Documentation)}</param>");
        }
    }

    /// <summary>
    /// Appends the HTTP method attribute.
    /// </summary>
    private static void AppendHttpMethodAttribute(StringBuilder sb, ControllerMethodDefinition method, string indent)
    {
        if (method.Deprecated)
        {
            sb.AppendLine($"{indent}[Obsolete]");
        }

        var routeMethod = SanitizeName(method.HttpMethod.Method.ToLower(), pascalCase: true);
        var attributeLine = string.IsNullOrEmpty(method.Route)
            ? $"{indent}[Http{routeMethod}]"
            : $"{indent}[Http{routeMethod}(\"{method.Route}\")]";

        sb.AppendLine(attributeLine);
    }

    /// <summary>
    /// Appends the method signature.
    /// </summary>
    private void AppendMethodSignature(StringBuilder sb, ControllerMethodDefinition method, string indent)
    {
        var taskWrapper = _configuration.UseAsyncControllers ? "Task<" : "";
        var taskEnd = _configuration.UseAsyncControllers ? ">" : "";

        sb.Append($"{indent}public abstract {taskWrapper}{method.ReturnType}{taskEnd} {method.Name}(");

        var parameters = method.Parameters
            .Select(FormatParameter)
            .ToList();

        sb.Append(string.Join(", ", parameters));
        sb.AppendLine(");");
    }

    /// <summary>
    /// Sorts parameters according to C# method signature conventions:
    /// 1. Required non-nullable parameters
    /// 2. Required nullable parameters
    /// 3. Optional parameters (with default values)
    /// Within each group, sorted by source: FromRoute, FromQuery, FromHeader, FromBody.
    /// </summary>
    private static List<ControllerParameterDefinition> SortParametersByRequirement(List<ControllerParameterDefinition> parameters)
    {
        return parameters
            .OrderBy(p => p.DefaultValue != null ? 1 : 0) // Parameters with default values last (optional)
            .ThenBy(p => IsNullableType(p.Type) ? 1 : 0) // Non-nullable before nullable (within required group)
            .ThenBy(GetParameterSortOrder) // Then by source (Path, Query, Header, Body)
            .ToList();
    }

    /// <summary>
    /// Gets the sort order for a parameter based on its source (ASP.NET Core conventions).
    /// </summary>
    private static int GetParameterSortOrder(ControllerParameterDefinition param)
    {
        return param.Source switch
        {
            ControllerParameterSource.Path => 0, // FromRoute first
            ControllerParameterSource.Query => 1, // FromQuery second
            ControllerParameterSource.Header => 2, // FromHeader third
            ControllerParameterSource.Body => 3, // FromBody last
            _ => 4 // Others at the end
        };
    }

    /// <summary>
    /// Determines if a C# type string represents a nullable type.
    /// </summary>
    private static bool IsNullableType(string type)
    {
        if (string.IsNullOrWhiteSpace(type))
            return false;

        // Check for nullable value types (int?, bool?, etc.)
        if (type.EndsWith("?") && !type.EndsWith(">?"))
            return true;

        // Check for nullable reference types in collections
        // Don't consider ICollection<string?> as nullable, only string? itself
        return false;
    }

    /// <summary>
    /// Formats a parameter with its attributes, type, name and optional default value.
    /// </summary>
    private static string FormatParameter(ControllerParameterDefinition param)
    {
        var result = $"{GetParameterAttribute(param.Source)}{param.Type} {param.Name}";

        if (param.DefaultValue != null)
        {
            // Format default value based on type
            var defaultValue = FormatDefaultValue(param.DefaultValue, param.Type);
            result += $" = {defaultValue}";
        }

        return result;
    }

    /// <summary>
    /// Formats a default value according to the parameter type.
    /// </summary>
    private static string FormatDefaultValue(string value, string type)
    {
        // Handle null value
        if (string.IsNullOrWhiteSpace(value) || value.Equals("null", StringComparison.OrdinalIgnoreCase))
        {
            return "null";
        }

        // String types need quotes
        if (type == "string" || type == "string?")
        {
            return $"\"{value}\"";
        }

        // Boolean
        if (type == "bool" || type == "bool?")
        {
            return bool.TryParse(value, out var boolValue) ? boolValue.ToString().ToLower() : "false";
        }

        // Numeric types - use as-is
        if (type.StartsWith("int") || type.StartsWith("long") || type.StartsWith("decimal") ||
            type.StartsWith("double") || type.StartsWith("float"))
        {
            return value;
        }

        // Default: return as-is
        return value;
    }

    /// <summary>
    /// Gets the method name from an operation, using operationId or generating from path.
    /// </summary>
    private static string GetMethodName(OpenApiOperation operation, string path, HttpMethod httpMethod)
    {
        if (operation.OperationId is not null && !string.IsNullOrWhiteSpace(operation.OperationId))
        {
            return SanitizeName(operation.OperationId, pascalCase: true);
        }

        // Fallback: use HTTP method + path segments
        var flatName = (httpMethod.ToString().ToLower() + '_' + path.ToSnakeCase())
            .Replace("/", "_")
            .Replace("{", "_by_")
            .Replace("}", "")
            .ToLower();

        return SanitizeName(flatName, pascalCase: true);
    }

    /// <summary>
    /// Gets the C# type for a parameter.
    /// </summary>
    private static string GetParameterType(IOpenApiParameter parameter)
    {
        return parameter.Schema == null ? "string" : TypeUtils.DetermineFinalType(parameter.Schema);
    }

    /// <summary>
    /// Gets the parameter attribute based on its source.
    /// </summary>
    private static string GetParameterAttribute(ControllerParameterSource source)
    {
        return source switch
        {
            ControllerParameterSource.Path => "[FromRoute] ",
            ControllerParameterSource.Header => "[FromHeader] ",
            ControllerParameterSource.Query => "[FromQuery] ",
            ControllerParameterSource.Body => "[FromBody] ",
            _ => ""
        };
    }

    /// <summary>
    /// Gets the C# type for a request body.
    /// </summary>
    private static string GetRequestBodyType(IOpenApiRequestBody requestBody, OpenApiDocument _)
    {
        if (requestBody.Content == null || requestBody.Content.Count == 0)
        {
            return "object";
        }

        var mediaType = requestBody.Content.FirstOrDefault().Value;
        if (mediaType?.Schema == null)
        {
            return "object";
        }

        return TypeUtils.DetermineFinalType(mediaType.Schema);
    }

    /// <summary>
    /// Converts an OpenAPI path to an ASP.NET Core route template.
    /// </summary>
    private static string ConvertPathToRouteTemplate(string openApiPath)
    {
        return openApiPath.TrimStart('/');
    }

    /// <summary>
    /// Sanitizes a name to be a valid C# identifier, optionally converting to PascalCase.
    /// </summary>
    private static string SanitizeName(string name, bool pascalCase = false)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            return "Unnamed";
        }

        var sanitized = new StringBuilder();
        var nextUpper = pascalCase;

        foreach (var c in name)
        {
            if (char.IsLetterOrDigit(c))
            {
                sanitized.Append(nextUpper ? char.ToUpper(c) : c);
                nextUpper = false;
            }
            else if (c is '_' or '-' or '.' or ' ')
            {
                nextUpper = true;
            }
        }

        var result = sanitized.ToString();

        if (result.Length == 0 || !char.IsLetter(result[0]))
        {
            result = "Action" + result;
        }

        return result;
    }

    /// <summary>
    /// Escapes special XML characters in a comment.
    /// </summary>
    private static string EscapeXmlComment(string comment)
    {
        return comment
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;")
            .Replace("\"", "&quot;")
            .Replace("'", "&apos;");
    }
}
