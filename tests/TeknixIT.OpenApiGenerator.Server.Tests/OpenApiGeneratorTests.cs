using System.Collections.Immutable;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

namespace TeknixIT.OpenApiGenerator.Server.Tests;

/// <summary>
/// Comprehensive tests for the OpenAPI generator
/// </summary>
[TestFixture]
public class OpenApiGeneratorTests
{
    private string _testDataDirectory = string.Empty;

    [SetUp]
    public void Setup()
    {
        var testDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
        if (testDirectory == null)
        {
            throw new InvalidOperationException("Unable to determine test directory");
        }
        _testDataDirectory = Path.Combine(testDirectory, "TestData");

        if (!Directory.Exists(_testDataDirectory))
        {
            Directory.CreateDirectory(_testDataDirectory);
        }
    }

    #region Basic Tests

    [Test]
    public void SimpleApi_ShouldGenerateContractsAndControllers()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "simple-api.yaml");
        var config = CreateDefaultConfiguration();

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        Assert.That(result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error), Is.Empty,
            "No errors should be generated");

        var sources = result.GeneratedSources;
        Assert.That(sources, Is.Not.Empty, "Files should be generated");

        // Verify that the User contract is generated with exact content
        var userContract = sources.FirstOrDefault(s => s.HintName == "User.g.cs");
        Assert.That(userContract.HintName, Is.Not.Null, "The User contract should be generated");

        const string expectedUserContract = """

                                                        // <auto-generated />
                                                        #nullable enable

                                                        using System;
                                                        using System.Collections.Generic;
                                                        using System.ComponentModel.DataAnnotations;

                                                        namespace TestApp.Contracts;

                                                        public record User
                                                        {
                                                            [Required]
                                                            public required string Id { get; set; }
                                                            [Required]
                                                            public required string Name { get; set; }
                                                            [Required]
                                                            public required string Email { get; set; }
                                                        }

                                            """;

        AssertSourceEquals(userContract.SourceText.ToString(), expectedUserContract, "User.g.cs");

        // Verify that the Users controller is generated with exact content
        var usersController = sources.FirstOrDefault(s => s.HintName == "UsersController.g.cs");
        Assert.That(usersController.HintName, Is.Not.Null, "The Users controller should be generated");

        const string expectedUsersController = """

                                                           // <auto-generated />
                                                           #nullable enable

                                                           using System;
                                                           using System.Collections.Generic;
                                                           using System.Threading.Tasks;
                                                           using Microsoft.AspNetCore.Mvc;
                                                           using TestApp.Contracts;

                                                           namespace TestApp.Controllers;

                                                           /// <summary>
                                                           /// Controller for Users
                                                           /// </summary>
                                                           [ApiController]
                                                           [Route("/users")]
                                                           public abstract class UsersControllerBase : ControllerBase
                                                           {
                                                               /// <summary>
                                                               /// No description available.
                                                               /// </summary>
                                                               /// <param name="id"></param>
                                                               [HttpGet("{id}")]
                                                               public abstract Task<IActionResult> GetUser([FromRoute] string id);

                                                           }

                                               """;

        AssertSourceEquals(usersController.SourceText.ToString(), expectedUsersController, "UsersController.g.cs");
    }

    [Test]
    public void ComplexApi_ShouldGenerateAllComponents()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "complex-api.yaml");
        var config = CreateDefaultConfiguration();

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        Assert.That(result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error), Is.Empty);

        var sources = result.GeneratedSources;

        // Verify the schemas
        Assert.That(sources.Any(s => s.HintName == "Product.g.cs"), Is.True);
        Assert.That(sources.Any(s => s.HintName == "CreateProductRequest.g.cs"), Is.True);
        Assert.That(sources.Any(s => s.HintName == "UpdateProductRequest.g.cs"), Is.True);
        Assert.That(sources.Any(s => s.HintName == "ProductStatus.g.cs"), Is.True);

        // Verify the controller
        Assert.That(sources.Any(s => s.HintName == "ProductsController.g.cs"), Is.True);

        // Verify the ProductStatus enum with exact content
        var productStatus = sources.First(s => s.HintName == "ProductStatus.g.cs");

        var expectedProductStatus = """

                                                // <auto-generated />
                                                #nullable enable

                                                using System;
                                                using System.Collections.Generic;
                                                using System.ComponentModel.DataAnnotations;

                                                namespace TestApp.Contracts;

                                                public enum ProductStatus
                                                {
                                                    /// <summary>
                                                    /// Draft
                                                    /// </summary>
                                                    Draft,
                                                    /// <summary>
                                                    /// Active
                                                    /// </summary>
                                                    Active,
                                                    /// <summary>
                                                    /// Archived
                                                    /// </summary>
                                                    Archived
                                                }

                                    """;

        AssertSourceEquals(productStatus.SourceText.ToString(), expectedProductStatus, "ProductStatus.g.cs");
    }

    [Test]
    public void EmptyApi_ShouldNotGenerateFiles()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "empty-api.yaml");
        var config = CreateDefaultConfiguration();

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        Assert.That(result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error), Is.Empty,
            "No errors should be generated even for an empty API");
        Assert.That(result.GeneratedSources.Length, Is.EqualTo(0),
            "No files should be generated for an empty API");
    }

    #endregion

    #region Validation Tests

    [Test]
    public void ValidationApi_WithValidationEnabled_ShouldGenerateValidationAttributes()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "validation-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.GenerateValidationAttributes"] = "true";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var validationModel = result.GeneratedSources.FirstOrDefault(s => s.HintName == "ValidationModel.g.cs");
        Assert.That(validationModel.HintName, Is.Not.Null);

        var sourceText = validationModel.SourceText.ToString();

        // Verify the validation attributes
        AssertContainsLinesInOrder(sourceText,
            "using System.ComponentModel.DataAnnotations;",
            "namespace TestApp.Contracts;",
            "public record ValidationModel",
            "[StringLength(20, MinimumLength = 3)]",
            "public required string Username",
            "[Range(18, 120)]",
            "public required int Age"
        );
    }

    [Test]
    public void ValidationApi_WithValidationDisabled_ShouldNotGenerateValidationAttributes()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "validation-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.GenerateValidationAttributes"] = "false";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var validationModel = result.GeneratedSources.FirstOrDefault(s => s.HintName == "ValidationModel.g.cs");
        Assert.That(validationModel.HintName, Is.Not.Null);

        var sourceText = validationModel.SourceText.ToString();

        // Should not contain validation attributes
        Assert.That(sourceText.Trim().Replace(" ", "").Contains("[MinLength"), Is.False);
        Assert.That(sourceText.Trim().Replace(" ", "").Contains("[MaxLength"), Is.False);
    }

    #endregion

    #region Enum Tests

    [Test]
    public void EnumApi_ShouldGenerateEnums()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "enum-api.yaml");
        var config = CreateDefaultConfiguration();

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        // Verify OrderStatus enum with exact content
        var orderStatus = result.GeneratedSources.FirstOrDefault(s => s.HintName == "OrderStatus.g.cs");
        Assert.That(orderStatus.HintName, Is.Not.Null);

        var expectedOrderStatus = """

                                              // <auto-generated />
                                              #nullable enable

                                              using System;
                                              using System.Collections.Generic;
                                              using System.ComponentModel.DataAnnotations;

                                              namespace TestApp.Contracts;

                                              public enum OrderStatus
                                              {
                                                  /// <summary>
                                                  /// Pending
                                                  /// </summary>
                                                  Pending,
                                                  /// <summary>
                                                  /// Processing
                                                  /// </summary>
                                                  Processing,
                                                  /// <summary>
                                                  /// Completed
                                                  /// </summary>
                                                  Completed,
                                                  /// <summary>
                                                  /// Cancelled
                                                  /// </summary>
                                                  Cancelled
                                              }

                                  """;

        AssertSourceEquals(orderStatus.SourceText.ToString(), expectedOrderStatus, "OrderStatus.g.cs");

        // Verify Priority enum with exact content
        var priority = result.GeneratedSources.FirstOrDefault(s => s.HintName == "Priority.g.cs");
        Assert.That(priority.HintName, Is.Not.Null);

        var expectedPriority = """

                                           // <auto-generated />
                                           #nullable enable

                                           using System;
                                           using System.Collections.Generic;
                                           using System.ComponentModel.DataAnnotations;

                                           namespace TestApp.Contracts;

                                           public enum Priority
                                           {
                                               /// <summary>
                                               /// Low
                                               /// </summary>
                                               Low,
                                               /// <summary>
                                               /// Medium
                                               /// </summary>
                                               Medium,
                                               /// <summary>
                                               /// High
                                               /// </summary>
                                               High,
                                               /// <summary>
                                               /// Urgent
                                               /// </summary>
                                               Urgent
                                           }

                               """;

        AssertSourceEquals(priority.SourceText.ToString(), expectedPriority, "Priority.g.cs");

        // Verify PaymentMethod enum with exact content
        var paymentMethod = result.GeneratedSources.FirstOrDefault(s => s.HintName == "PaymentMethod.g.cs");
        Assert.That(paymentMethod.HintName, Is.Not.Null);

        var expectedPaymentMethod = """

                                                // <auto-generated />
                                                #nullable enable

                                                using System;
                                                using System.Collections.Generic;
                                                using System.ComponentModel.DataAnnotations;

                                                namespace TestApp.Contracts;

                                                public enum PaymentMethod
                                                {
                                                    /// <summary>
                                                    /// CreditCard
                                                    /// </summary>
                                                    CreditCard,
                                                    /// <summary>
                                                    /// DebitCard
                                                    /// </summary>
                                                    DebitCard,
                                                    /// <summary>
                                                    /// PayPal
                                                    /// </summary>
                                                    PayPal,
                                                    /// <summary>
                                                    /// BankTransfer
                                                    /// </summary>
                                                    BankTransfer
                                                }

                                    """;

        AssertSourceEquals(paymentMethod.SourceText.ToString(), expectedPaymentMethod, "PaymentMethod.g.cs");
    }

    #endregion

    #region Configuration Tests

    [Test]
    public void Configuration_WithCustomNamespace_ShouldUseCustomNamespace()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "simple-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.BaseNamespace"] = "MyApp.Api";
        config["build_metadata.AdditionalFiles.ContractsNamespace"] = "Models";
        config["build_metadata.AdditionalFiles.ControllersNamespace"] = "Endpoints";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var userContract = result.GeneratedSources.First(s => s.HintName == "User.g.cs");
        AssertContainsLinesInOrder(userContract.SourceText.ToString(),
            "namespace MyApp.Api.Models;",
            "public record User"
        );

        var controller = result.GeneratedSources.First(s => s.HintName == "UsersController.g.cs");
        AssertContainsLinesInOrder(controller.SourceText.ToString(),
            "using MyApp.Api.Models;",
            "namespace MyApp.Api.Endpoints;",
            "public abstract class UsersControllerBase"
        );
    }

    [Test]
    public void Configuration_WithAsyncControllers_ShouldGenerateAsyncMethods()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "simple-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.UseAsyncControllers"] = "true";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var controller = result.GeneratedSources.First(s => s.HintName == "UsersController.g.cs");
        AssertContainsLine(controller.SourceText.ToString(), "Task<IActionResult>");
    }

    [Test]
    public void Configuration_WithSyncControllers_ShouldGenerateSyncMethods()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "simple-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.UseAsyncControllers"] = "false";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var controller = result.GeneratedSources.First(s => s.HintName == "UsersController.g.cs");
        var sourceText = controller.SourceText.ToString();
        AssertContainsLine(sourceText, "IActionResult GetUser(");
    }

    [Test]
    public void Configuration_OnlyContracts_ShouldNotGenerateControllers()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "simple-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.GenerateControllers"] = "false";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        Assert.That(result.GeneratedSources.Any(s => s.HintName == "User.g.cs"), Is.True,
            "Contracts should be generated");
        Assert.That(result.GeneratedSources.Any(s => s.HintName.EndsWith("Controller.g.cs")), Is.False,
            "Controllers should not be generated");
    }

    [Test]
    public void Configuration_WithApiControllerAttribute_ShouldAddAttribute()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "simple-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.AddApiControllerAttribute"] = "true";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var controller = result.GeneratedSources.First(s => s.HintName == "UsersController.g.cs");
        AssertContainsLine(controller.SourceText.ToString(), "[ApiController]");
    }

    [Test]
    public void Configuration_WithoutApiControllerAttribute_ShouldNotAddAttribute()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "simple-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.AddApiControllerAttribute"] = "false";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var controller = result.GeneratedSources.First(s => s.HintName == "UsersController.g.cs");
        var sourceText = controller.SourceText.ToString();
        Assert.That(sourceText.Trim().Replace(" ", "").Contains("[ApiController]"), Is.False);
    }

    [Test]
    public void Configuration_WithCustomControllerBaseClass_ShouldInheritFromCustomClass()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "simple-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.ControllerBaseClass"] = "MyApp.Controllers.BaseApiController";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var controller = result.GeneratedSources.First(s => s.HintName == "UsersController.g.cs");
        AssertContainsLine(controller.SourceText.ToString(), ": BaseApiController");
    }

    #endregion

    #region Controller Grouping Strategy Tests

    [Test]
    public void ControllerGroupingStrategy_ByTag_ShouldGroupByTags()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "grouping-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.ControllerGroupingStrategy"] = "ByTag";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        Assert.That(result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error), Is.Empty);

        // Should have 3 controllers: Users, Products, Orders
        var controllers = result.GeneratedSources.Where(s => s.HintName.EndsWith("Controller.g.cs")).ToArray();
        Assert.That(controllers.Length, Is.EqualTo(3), "Should have 3 controllers when grouping by tag");

        Assert.That(controllers.Any(s => s.HintName == "UsersController.g.cs"), Is.True, "UsersController should exist");
        Assert.That(controllers.Any(s => s.HintName == "ProductsController.g.cs"), Is.True, "ProductsController should exist");
        Assert.That(controllers.Any(s => s.HintName == "OrdersController.g.cs"), Is.True, "OrdersController should exist");

        // Verify Users controller has both endpoints
        var usersController = controllers.First(s => s.HintName == "UsersController.g.cs");
        var usersSource = usersController.SourceText.ToString();
        AssertContainsLine(usersSource, "ListUsers");
        AssertContainsLine(usersSource, "GetUser");
    }

    [Test]
    public void ControllerGroupingStrategy_ByFirstPathSegment_ShouldGroupByFirstSegment()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "grouping-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.ControllerGroupingStrategy"] = "ByFirstPathSegment";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        Assert.That(result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error), Is.Empty);

        // Should have 3 controllers: Users, Products, Orders (same as ByTag for this API)
        var controllers = result.GeneratedSources.Where(s => s.HintName.EndsWith("Controller.g.cs")).ToArray();
        Assert.That(controllers.Length, Is.EqualTo(3), "Should have 3 controllers when grouping by first path segment");

        Assert.That(controllers.Any(s => s.HintName == "UsersController.g.cs"), Is.True);
        Assert.That(controllers.Any(s => s.HintName == "ProductsController.g.cs"), Is.True);
        Assert.That(controllers.Any(s => s.HintName == "OrdersController.g.cs"), Is.True);

        // Verify Orders controller has both pending and completed endpoints
        var ordersController = controllers.First(s => s.HintName == "OrdersController.g.cs");
        var ordersSource = ordersController.SourceText.ToString();
        AssertContainsLine(ordersSource, "ListPendingOrders");
        AssertContainsLine(ordersSource, "ListCompletedOrders");
    }

    [Test]
    public void ControllerGroupingStrategy_ByPath_ShouldCreateSeparateControllers()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "grouping-api.yaml");
        var config = CreateDefaultConfiguration();
        config["build_metadata.AdditionalFiles.ControllerGroupingStrategy"] = "ByPath";

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        Assert.That(result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error), Is.Empty);

        // Should have 4 controllers: Users, Products, OrdersPending, OrdersCompleted
        // Note: /users and /users/{id} are grouped together after removing parameters
        var controllers = result.GeneratedSources.Where(s => s.HintName.EndsWith("Controller.g.cs")).ToArray();
        Assert.That(controllers.Length, Is.EqualTo(4), "Should have 4 controllers when grouping by path");

        // Verify we have separate controllers for different paths
        Assert.That(controllers.Any(s => s.HintName == "UsersController.g.cs"), Is.True);
        Assert.That(controllers.Any(s => s.HintName == "ProductsController.g.cs"), Is.True);
        Assert.That(controllers.Any(s => s.HintName == "OrdersPendingController.g.cs"), Is.True);
        Assert.That(controllers.Any(s => s.HintName == "OrdersCompletedController.g.cs"), Is.True);

        // Verify that Users controller has both endpoints (since /users and /users/{id} share the same base path)
        var usersController = controllers.First(s => s.HintName == "UsersController.g.cs");
        var usersSource = usersController.SourceText.ToString();
        AssertContainsLine(usersSource, "ListUsers");
        AssertContainsLine(usersSource, "GetUser");
    }

    [Test]
    public void ControllerGroupingStrategy_DefaultIsByTag()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "grouping-api.yaml");
        var config = CreateDefaultConfiguration();
        // Don't set ControllerGroupingStrategy - should default to ByTag

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        Assert.That(result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error), Is.Empty);

        // Should have 3 controllers like ByTag
        var controllers = result.GeneratedSources.Where(s => s.HintName.EndsWith("Controller.g.cs")).ToArray();
        Assert.That(controllers.Length, Is.EqualTo(3), "Default grouping strategy should be ByTag");
    }

    #endregion

    #region Nested Objects Tests

    [Test]
    public void NestedObjects_ShouldGenerateAllSchemas()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "nested-api.yaml");
        var config = CreateDefaultConfiguration();

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        Assert.That(result.GeneratedSources.Any(s => s.HintName == "Company.g.cs"), Is.True);
        Assert.That(result.GeneratedSources.Any(s => s.HintName == "Address.g.cs"), Is.True);
        Assert.That(result.GeneratedSources.Any(s => s.HintName == "Employee.g.cs"), Is.True);

        // Verify that Company references Address and Employee
        var company = result.GeneratedSources.First(s => s.HintName == "Company.g.cs");
        AssertContainsLinesInOrder(company.SourceText.ToString(),
            "public record Company",
            "public required string Name { get; set; }",
            "public required Address Address { get; set; }",
            "public required ICollection<Employee> Employees { get; set; }"
        );
    }

    #endregion

    #region Parameter Types Tests

    [Test]
    public void ComplexApi_ShouldHandleVariousParameterTypes()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "complex-api.yaml");
        var config = CreateDefaultConfiguration();

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var controller = result.GeneratedSources.First(s => s.HintName == "ProductsController.g.cs");
        var sourceText = controller.SourceText.ToString();

        // Verify various parameter types in correct order
        AssertContainsLine(sourceText, "public abstract Task<IActionResult> ListProducts([FromQuery] string category, [FromQuery] double minPrice");
        AssertContainsLine(sourceText, "long id"); // path param long in different method
    }

    #endregion

    #region Tests HTTP Methods

    [Test]
    public void ComplexApi_ShouldGenerateAllHttpMethods()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "complex-api.yaml");
        var config = CreateDefaultConfiguration();

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var controller = result.GeneratedSources.First(s => s.HintName == "ProductsController.g.cs");
        var sourceText = controller.SourceText.ToString();

        // Verify HTTP attributes appear in proper structure
        AssertContainsLine(sourceText, "[HttpGet]");
        AssertLineAfter(sourceText, "[HttpGet]", "public abstract Task<IActionResult> ListProducts");
        AssertContainsLine(sourceText, "[HttpPost]");
        AssertLineAfter(sourceText, "[HttpPost]", "public abstract Task<IActionResult> CreateProduct");
        AssertContainsLine(sourceText, "[HttpPut");
        AssertContainsLine(sourceText, "[HttpDelete");
    }

    #endregion

    #region Required vs Optional Properties Tests

    [Test]
    public void Product_ShouldHaveRequiredAndOptionalProperties()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "complex-api.yaml");
        var config = CreateDefaultConfiguration();

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var product = result.GeneratedSources.First(s => s.HintName == "Product.g.cs");
        var sourceText = product.SourceText.ToString();

        // Verify properties are in order
        AssertContainsLinesInOrder(sourceText,
            "public record Product",
            "public required long Id { get; set; }",
            "public required string Name { get; set; }",
            "public required string Description { get; set; }",
            "public required double Price { get; set; }",
            "public required string Category { get; set; }",
            "public required ProductStatus Status { get; set; }"
        );
    }

    #endregion

    #region Data Types Tests

    [Test]
    public void Product_ShouldUseCorrectDataTypes()
    {
        // Arrange
        var openApiFile = Path.Combine(_testDataDirectory, "complex-api.yaml");
        var config = CreateDefaultConfiguration();

        // Act
        var result = RunGenerator(openApiFile, config);

        // Assert
        var product = result.GeneratedSources.First(s => s.HintName == "Product.g.cs");
        var sourceText = product.SourceText.ToString();

        // Verify correct data types in order
        AssertContainsLinesInOrder(sourceText,
            "public record Product",
            "long Id", // integer format int64 -> long
            "string Name", // string -> string
            "double Price", // number format double -> double
            "ProductStatus Status", // enum reference
            "ICollection<string>", // array -> ICollection
            "DateTime" // date-time -> DateTime
        );
    }

    #endregion

    #region Invalid File Tests

    [Test]
    public void InvalidOpenApiFile_ShouldReportError()
    {
        // Arrange
        var invalidFile = Path.Combine(_testDataDirectory, "invalid-api.yaml");
        File.WriteAllText(invalidFile, "this is not valid yaml: {[}]");

        var config = CreateDefaultConfiguration();

        // Act
        var result = RunGenerator(invalidFile, config);

        // Assert
        var errors = result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error).ToArray();
        Assert.That(errors, Is.Not.Empty, "Errors should be reported for an invalid file");

        // Cleanup
        if (File.Exists(invalidFile))
        {
            File.Delete(invalidFile);
        }
    }

    [Test]
    public void NonExistentFile_ShouldReportError()
    {
        // Arrange
        var nonExistentFile = Path.Combine(_testDataDirectory, "does-not-exist.yaml");
        var config = CreateDefaultConfiguration();

        // Act
        var result = RunGenerator(nonExistentFile, config);

        // Assert
        var errors = result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error).ToArray();
        Assert.That(errors, Is.Not.Empty, "Errors should be reported for a non-existent file");
    }

    #endregion

    #region Helpers

    private static Dictionary<string, string> CreateDefaultConfiguration()
    {
        return new Dictionary<string, string>
        {
            ["build_metadata.AdditionalFiles.SourceItemType"] = "OpenApiGeneratorServer",
            ["build_metadata.AdditionalFiles.GenerateControllers"] = "true",
            ["build_metadata.AdditionalFiles.BaseNamespace"] = "TestApp",
            ["build_metadata.AdditionalFiles.ContractsNamespace"] = "Contracts",
            ["build_metadata.AdditionalFiles.ControllersNamespace"] = "Controllers",
            ["build_metadata.AdditionalFiles.UseAsyncControllers"] = "true",
            ["build_metadata.AdditionalFiles.GenerateValidationAttributes"] = "true",
            ["build_metadata.AdditionalFiles.AddApiControllerAttribute"] = "true",
            ["build_metadata.AdditionalFiles.ControllerBaseClass"] = "ControllerBase",
            ["build_metadata.AdditionalFiles.UseRecords"] = "true",
            ["build_metadata.AdditionalFiles.GenerateXmlDocumentation"] = "true"
        };
    }

    private static GeneratorRunResult RunGenerator(string openApiFile, Dictionary<string, string> config)
    {
        var compilation = CreateCompilation();

        var additionalFiles = ImmutableArray.Create<AdditionalText>(
            new TestAdditionalText(openApiFile));

        var optionsProvider = new TestAnalyzerConfigOptionsProvider(openApiFile, config);

        var generator = new OpenApiSourceGenerator();

        GeneratorDriver driver = CSharpGeneratorDriver.Create(
            generators: [generator.AsSourceGenerator()],
            additionalTexts: additionalFiles,
            optionsProvider: optionsProvider);

        driver = driver.RunGeneratorsAndUpdateCompilation(
            compilation,
            out Compilation _,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        var generatorResult = runResult.Results[0];

        return new GeneratorRunResult { GeneratedSources = generatorResult.GeneratedSources, Diagnostics = diagnostics, Exception = generatorResult.Exception };
    }

    private static CSharpCompilation CreateCompilation()
    {
        var syntaxTree = CSharpSyntaxTree.ParseText("""

                                                    namespace TestNamespace
                                                    {
                                                        public class TestClass { }
                                                    }
                                                    """);

        var references = AppDomain.CurrentDomain.GetAssemblies()
            .Where(a => !a.IsDynamic && !string.IsNullOrWhiteSpace(a.Location))
            .Select(a => MetadataReference.CreateFromFile(a.Location))
            .ToList();

        return CSharpCompilation.Create(
            assemblyName: "TestAssembly",
            syntaxTrees: [syntaxTree],
            references: references,
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
    }

    /// <summary>
    /// Verifies that a line of code exists in the source, ignoring leading whitespace
    /// </summary>
    private static void AssertContainsLine(string source, string expectedLine)
    {
        var lines = source.Split('\n')
            .Select(line => line.TrimStart()) // Remove leading spaces
            .Where(line => !string.IsNullOrWhiteSpace(line))
            .ToList();

        var normalizedExpected = expectedLine.TrimStart();

        var found = lines.Any(line => line.Contains(normalizedExpected));

        Assert.That(found, Is.True,
            $"Expected line not found:\n" +
            $"Expected: {normalizedExpected}\n" +
            $"In file:\n{source}");
    }

    /// <summary>
    /// Compares two source files line by line, ignoring leading/trailing whitespace differences
    /// </summary>
    private static void AssertSourceEquals(string actualSource, string expectedSource, string fileName = "")
    {
        var actualLines = actualSource.Split('\n')
            .Select(line => line.Trim())
            .Where(line => !string.IsNullOrWhiteSpace(line))
            .ToList();

        var expectedLines = expectedSource.Split('\n')
            .Select(line => line.Trim())
            .Where(line => !string.IsNullOrWhiteSpace(line))
            .ToList();

        // First check if line counts match
        if (actualLines.Count != expectedLines.Count)
        {
            var diff = new StringBuilder();
            diff.AppendLine($"Line count mismatch in {fileName}:");
            diff.AppendLine($"Expected: {expectedLines.Count} lines");
            diff.AppendLine($"Actual: {actualLines.Count} lines");
            diff.AppendLine();
            diff.AppendLine("Expected content:");
            diff.AppendLine(expectedSource);
            diff.AppendLine();
            diff.AppendLine("Actual content:");
            diff.AppendLine(actualSource);

            Assert.Fail(diff.ToString());
        }

        // Compare line by line
        for (int i = 0; i < expectedLines.Count; i++)
        {
            if (actualLines[i] == expectedLines[i])
            {
                continue;
            }

            var diff = new StringBuilder();
            diff.AppendLine($"Line mismatch at line {i + 1} in {fileName}:");
            diff.AppendLine($"Expected: {expectedLines[i]}");
            diff.AppendLine($"Actual:   {actualLines[i]}");
            diff.AppendLine();
            diff.AppendLine($"Context (lines {Math.Max(0, i - 2)} to {Math.Min(expectedLines.Count - 1, i + 2)}):");
            for (int j = Math.Max(0, i - 2); j <= Math.Min(expectedLines.Count - 1, i + 2); j++)
            {
                string marker = j == i ? ">>> " : "    ";
                diff.AppendLine($"{marker}{j + 1}: {(j < actualLines.Count ? actualLines[j] : "[missing]")}");
            }

            Assert.Fail(diff.ToString());
        }
    }

    /// <summary>
    /// Verifies that multiple lines appear in order in the source, ignoring leading whitespace
    /// </summary>
    private static void AssertContainsLinesInOrder(string source, params string[] expectedLines)
    {
        var lines = source.Split('\n')
            .Select(line => line.TrimStart()) // Remove leading spaces
            .Where(line => !string.IsNullOrWhiteSpace(line))
            .ToList();

        var normalizedExpected = expectedLines.Select(line => line.TrimStart()).ToArray();

        int currentLineIndex = 0;
        int expectedIndex = 0;

        while (currentLineIndex < lines.Count && expectedIndex < normalizedExpected.Length)
        {
            if (lines[currentLineIndex].Contains(normalizedExpected[expectedIndex]))
            {
                expectedIndex++;
            }
            currentLineIndex++;
        }

        Assert.That(expectedIndex, Is.EqualTo(normalizedExpected.Length),
            $"Expected lines not found in order:\n" +
            $"Found {expectedIndex} of {normalizedExpected.Length} expected lines\n" +
            $"Missing line: {(expectedIndex < normalizedExpected.Length ? normalizedExpected[expectedIndex] : "none")}\n" +
            $"Expected lines:\n{string.Join("\n", normalizedExpected)}\n" +
            $"In file:\n{source}");
    }

    /// <summary>
    /// Verifies that a line appears after another line in the source
    /// </summary>
    private static void AssertLineAfter(string source, string lineBefore, string lineAfter)
    {
        var lines = source.Split('\n')
            .Select(line => line.TrimStart())
            .Where(line => !string.IsNullOrWhiteSpace(line))
            .ToList();

        var normalizedBefore = lineBefore.TrimStart();
        var normalizedAfter = lineAfter.TrimStart();

        int beforeIndex = -1;
        int afterIndex = -1;

        for (int i = 0; i < lines.Count; i++)
        {
            if (beforeIndex == -1 && lines[i].Contains(normalizedBefore))
            {
                beforeIndex = i;
            }
            else if (beforeIndex != -1 && lines[i].Contains(normalizedAfter))
            {
                afterIndex = i;
                break;
            }
        }

        Assert.That(beforeIndex, Is.GreaterThanOrEqualTo(0),
            $"Line '{normalizedBefore}' not found in source");
        Assert.That(afterIndex, Is.GreaterThan(beforeIndex),
            $"Line '{normalizedAfter}' should appear after '{normalizedBefore}'\n" +
            $"In file:\n{source}");
    }

    #endregion

    #region Test Helper Classes

    private class GeneratorRunResult
    {
        public ImmutableArray<GeneratedSourceResult> GeneratedSources { get; set; }
        public ImmutableArray<Diagnostic> Diagnostics { get; set; }
        public Exception? Exception { get; set; }
    }

    private class TestAdditionalText : AdditionalText
    {
        private readonly string _path;

        public TestAdditionalText(string path)
        {
            _path = path;
        }

        public override string Path => _path;

        public override SourceText GetText(CancellationToken cancellationToken = default)
        {
            return SourceText.From(!File.Exists(_path)
                ? string.Empty
                : File.ReadAllText(_path), Encoding.UTF8);
        }
    }

    private class TestAnalyzerConfigOptionsProvider : AnalyzerConfigOptionsProvider
    {
        private readonly TestAnalyzerConfigOptions _options;

        public TestAnalyzerConfigOptionsProvider(string filePath, Dictionary<string, string> options)
        {
            _options = new TestAnalyzerConfigOptions(filePath, options);
        }

        public override AnalyzerConfigOptions GlobalOptions => _options;

        public override AnalyzerConfigOptions GetOptions(SyntaxTree tree) => _options;

        public override AnalyzerConfigOptions GetOptions(AdditionalText textFile) => _options;
    }

    private class TestAnalyzerConfigOptions : AnalyzerConfigOptions
    {
        private readonly Dictionary<string, string> _options;

        public TestAnalyzerConfigOptions(string _, Dictionary<string, string> options)
        {
            _options = new Dictionary<string, string>(options);
        }

        public override bool TryGetValue(string key, out string value)
        {
            return _options.TryGetValue(key, out value!);
        }
    }

    #endregion
}
